

### 10.	Анализ и описание архитектурных опций и обоснование выбора

Выбор концептуальной архитектуры проекта можно сделать на основе сравнительного анализа различных архитектурных стилей, который представлен в таблице ниже.

| Архитектурный стиль | Плюсы | Минусы |
|---------------------|-------|--------|
| Монолит | |
|         |  Легкое развертывание и настройка. Достаточного развернуть артефакт монолита, чтобы все заработало | Завязка на текущем стеке технологий. Поменять стек технологий после начала разработки уже практически невозможно |
|         |  Легкое тестирование. Отсутствие сложных интеграций и распределенных взаимодействий позволяет легко проводить полные регрессионные тесты даже на машине разработчика| Риск разрастания. Пока монолит небольшой его легко разрабатывать и обслуживать. Однако, если монолит разрастается и уже не помещается в память одного разработчика - то становится крайне запутанным и сложным к понимаю, что существенно затрудняет разработку |
|         |  Скорость работы. Вызовы внутри приложения через IPC и отсутствие распределенных операций обеспечивают наилучшую производительность | Уязвимость к сбоям. Ошибка в работе любого компонента монолитного приложения может привести к неработоспособности всех остальных функций |
| Service Oriented Architecture | |  |
|                  |  Слабая связанность сервисов. Слабая связанность между сервисами позволяет достичь хорошей гибкости приложения |  |
|                  |  Относительная надежность. Выход из строя некритичного сервиса не повлечет за собой полную неработоспособность системы |  |
|                  |  Довольно легкая разработка и тестирования каждого сервиса в отдельности | Абсолютно все достоинства данной архитектуры полностью перекрываются наличием ESB - Enterprise Service Bus. Данный компонент является и главной точкой отказа, и главной проблемой с конфигурированием. Так же, через какое-то время в него начинает просачиваться бизнес-логика, что крайне запутывает и усложняет пониманием всей системы, её скорость работы, общее тестирование и дальнейшую разработку, а также привязывает систему к конкретному вендору ESB.   |
| Service Based Architecture | | |
|                                  | Простота реализации тестирования и развертывания. Единое хранилище данных позволяет быстро и удобно разворачивать и тестировать новые сервисы | |
|                                  | Хорошая гибкость, которая достигается реальной слабой связанностью сервисов. Возможность реализации отдельного интерфейса | Главным недостатком является плохая масштабируемость, в следствии наличия единого хранилища данных для всех сервисов |
| Space Based Architecture | | |
|                          | Гибкость. Модуль управления proccessing unit'ами может быстро поднимать или убирать новые юниты в зависимости от ситуации | |
|                          | Удобство развертывания.  Развертывание новых proccessing юнитов происходит через middleware, что делает процесс довольно легким и удобным | |
|                          |  Отличная производительность, которая достигается путем кэширования данных в оперативной памяти, а также балансировкой нагрузки, что позволяет обрабатывать данные на наименее загруженном юните | Главным недостаток является экстремально высокая сложность реализации и настройки решения, учитывающая оркестрацию, репликацию кеша, контроль состояния и т.д. Все это требует наличия стороннего ПО, а так же специалистов для него. Так же, основной задачей приложений написанных в таком стиле является работа под крайне сильной и неоднородной пользовательской нагрузкой. Такие условия крайне тяжело воспроизводятся в тестовых средах, поэтому по факту нет возможности адекватно протестировать систему |
| Event Driven Architecture| | |
|                          | Легкое расширение функционала, а также наращивание мощностей | Сложность реализации: компенсационные транзакции, асинхронная природа, контракты между сервисами| 
|                          | Легкое развертывание из-за крайне слабой связанности и независимости компонентов. Особенно при использовании брокера. При использовании медиатора может потребовать внести в него какие-то изменения. | Слабая согласованность данных|
|                          | Хорошая производительность, которая достигается за счет асинхронных операций ||
|                          | Прозрачность. За счет наличия событий, которые являются триггерами к действиям всегда можно понять почему изменилось состояние объекта ||
| Microservices | | |
|               | Гибкость за счет крайне слабой связанности компонентов | Производительность. Распределенное взаимодействие, а так же обычно большое количество сервисов существенным образом сказывается на производительности, в виду временных расходов на передачу данных между сервисами |
|               | Независимость в разработке. Обычно каждый микросервис раздобывается свой собственной командой, это позволяет развивать сервис отдельно от всей системы и релизить так часто, как это требуется. Так же это позволяет использовать именно тот технологический стек, который наиболее выигрышен именно для этого микросервиса| Контракт взаимодействия. Из-за множества независимых сервисов тяжело выработать единый контракт взаимодействия. 
|               | Масштабируемость и отказоустойчивость. Неограниченный потенциал в создании сервисов и их реплик |


**Обоснование выбора концептуальной архитектуры:**

Несмотря на то, что монолит обычно является стартовой точкой для развития любого приложения, а смена архитектурного стиля обычно происходит эволюционно, в связи с возникновением потребностей, в нашем случае это не так.
Контекст задачи сразу подразумевает высоко нагруженное, географически распределенное приложение с потенциально большим количеством интеграций. Поэтому следующие архитектурные стили, которые плохо масштабируется отпадают сразу:

* Монолит
* Service Oriented Architecture
* Service Based Architecture

Space Based Architecture - является крайне сложной в разработке и тестировании.

В таком случае остаются Event Driven Architecture и Microservices. Предлагается взять за основу микросервисную архитектуру и использовать Event Driven Architecture в некоторых сервисах (например, в сервисе создания заказов и итеграциях с магазином). Микросервисная архитектура выбрана главным образом из-за возможности обеспечивать хорошее масштабирование и отказоустойчивость системы. Скорость работы приложения не является критичным фактором и неизбежные latency из-за прохождения запроса через сервисы не будут критичны.
Так же, микросервисная архитектура позволит реализовать независимую друг от друга разработку компонентов, а также обеспечить развитие и обновление только тем компонентам, которые в этом будут нуждаться.

[ADR: Architecture Options](../ADR/architecture_options.md)
